## zm招银网络一面

##### 1、大端模式和小端模式区别

区别：大端模式中字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中；而与大端存储模式相反，在小端存储模式中，低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节。

##### 2、堆与栈的区别

##### 3、static readonly和const的区别

##### 4、结构体和共同体的区别

1）变量长度不同

结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元。

共用体变量所占的内存长度等于最长的成员的长度。

2）占用空间不同

结构体是同时存在的，并一次占用一段连续的内存空间；

而共用体则是多个共用成员占用同一个开始的内存地址，同时他们只能存在一个，所以空间大小就是最大那个所需的空间，如果单从一个共用体来讲，我们是不知道里面存的是什么内容，需要根据程序上下文才能确定。

##### 5、线程调度中sleep和wait区别

（1）属于不同的两个类，sleep()方法是线程类（Thread）的静态方法，wait()方法是Object类里的方法。

（2）sleep()方法不会释放锁，wait()方法释放对象锁。

（3）sleep()方法可以在任何地方使用，wait()方法则只能在同步方法或同步块中使用。

（4）sleep()必须捕获异常，wait()方法、notify()方法和notiftAll()方法不需要捕获异常。

（5）sleep()使线程进入阻塞状态（线程睡眠），wait()方法使线程进入等待队列（线程挂起），也就是阻塞类别不同。

##### 6、完全二叉树和满二叉树的区别

满二叉树——除了叶结点外每一个结点都有左右子女且叶结点都处在最底层的二叉树,。（这个似乎很好想像出来）完全二叉树——只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树；（这个，就说从满二叉树里，最下一层的叶子，如果是从右往左拿掉叶子，不论多少，都是完全的，如果不是从右往左拿，而是在中间拿掉了一个，就是不完全的）

##### 7、什么是AVL树？

##### 8、const和define的区别

1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用。

2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 

3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。

4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。

**const优点**

1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。

3）const可节省空间，避免不必要的内存分配，提高效率；define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大，const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝；

##### 9、虚函数和纯虚函数

##### 10、引用传递和指针传递

​    指针参数传递本质上是值传递，它所传递的是一个地址值。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。

　　引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

　　引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。　　

##### 11、快排和冒泡排序

##### 12、虚函数和纯虚函数

##### 13、vector和list区别

##### 14、const int \* 和 int \* const

int const *p 和const int *p意义一样，指向常量的指针

##### 15、tcp长连接和短连接

##### 16、拥塞控制有哪些？讲一下慢开始

##### 17、tcp的keep alive

##### 18、代码驼峰

 

## sjc华泰面经

**1、介绍项目—识别魔方，解算过程**

##### 2、测试相关理论知识，测试与开发的差别

##### 3、数据库

##### 4、list中泛型添加多种数据，找出所有数字

##### 5、购物网站、购物车，有3种商品，2个苹果，3个李子，5个桃子， 5个苹果，6个李子，3个桃子，购物时连续点击；逻辑流程；

##### 6、未来3-5年职业规划

##### 7、为什么选择华泰

##### 8、什么是多态

##### 9、C++纯虚类特点、纯虚类主要用于哪些场合

##### 10、malloc和new的区别（new和free一起使用的后果）

##### 11、const char * 和char * const

##### 12、平衡二叉树和普通二叉树区别

##### 13、堆排序、快排的主要思路

##### 14、计算机课程，大端法和小端法

##### 15、浮点数保存，浮点数比较大小

##### 16、单例模式使用场合、工厂模式

##### 17、放弃本身经历选择金融科技，如何看待金融科技

##### 18、测试岗位在华泰证券公司的作用

##### 19、如何优化测试环节，完善测试用例等等；

##### 20、测试行业，如何证实代码是否正确，可以打印log，并加保护，测试方法；

##### 21、个人情况，家庭和对象，工作地点；

 

## 华泰一面

##### 1、指针和引用的区别（初始化的不同）

##### 2、虚函数，析构函数

##### 3、为什么用智能指针

##### 4、虚函数和纯虚函数

##### 5、如何在硬盘上找出所有相同的文件

##### 6、最大的优点、缺点，最有成就感的一件事

##### 7、项目（难点、意义、困难）

##### 8、最近关注哪些技术

 

## 嵌入式面经

##### 1、为什么嵌入式不用C++？

这是一种偏见，其实C++已经开始进入嵌入式

C++优势：1）C++是不断更新的语言

2）C++有着更加丰富的特性，三大特性

3）C++引进新的设计模式，面向对象；

为什么现在不用呢？++是面向对象的，成员函数的工作原理和普通函数不太一样，他的成员变量寻址全是偏移地址+基址。也就是基地址加偏址，通过改变基地址，让函数操作不同对象，但偏地址都相同（这样相同的代码实现操作不同的对象成员变量），电脑的CPU是有支持基址加偏址的，在BX里存基地址，在SI里存偏址，一条指令就找到变量了。而嵌入式芯片寻址要么立即数寻址，要么寄存器寻址，通常没有偏址+基址的方式，如果要实现只能软件去偏址+基址，运行更慢。

 

## Cadence面经

##### 1、vector、list区别

##### 2、链表倒数第N个结点

##### 3、虚函数

##### 4、找坏的药，12345编号

##### 5、析构函数什么时候被定义为虚函数

##### 6、项目实现

 

##### 1、函数指针和指针函数

函数指针是指向函数的指针int (*fun)(int x,int y);

指针函数是返回值为指针的函数int* fun(int x,int y);

 

##### 2、内联函数和宏定义区别

内联函数有安全检查，宏定义无安全检查

##### 3、虚函数表存放位置

编译后，存放在只读数据段

##### 4、虚继承、多重继承

虚继承是为了解决菱形继承的问题，虚继承只保存一份间接基类的成员；

##### 5、mmap

内存映射，mmap() 系统调⽤函数会直接把内核缓冲区⾥的数据「映射」到⽤户空间，这样，操作系统 内核与⽤户空间就不需要再进⾏任何的数据拷⻉操作。



## vivo技术面6.23

1、介绍项目，项目遇到的BUG，怎么解决的，出现的问题是什么

2、如何比较一个字符串是否是另一个字符串的子串

3、比较两个字符串大小、如果限定长度呢

4、C++多态有哪些？

5、反问，需要学习的知识、部门主要做什么的



## 乐鑫技术面一面6.22

1、问项目、论文

2、是否有硬件基础

3、反问，工作节奏，部门工作

## VIVO HR面6.25

1、自我介绍（共享屏幕，被说PPT制作质量低，亮点少）

2、工作地点、薪资期望

3、大公司与小公司的区别差异

4、逆商需要提高

5、智力题，八个苹果，找出一个质量重的那个，两次机会

6、反问，个人发展建议

7、公司录取你的原因和不录取你的原因

## 华为海思提前了解

1、struct对齐

2、C++新特性

3、项目详细介绍，RRT优化、VPG夹爪抓取

4、堆内存和栈内存

5、git介绍，提交代码遇到冲突、提交远端步骤

6、处理问题单的流程

##### 7、右值引用使用场景

移动拷贝构造函数

##### 1、子网掩码的作用（又称为网络掩码、地址掩码、子网络遮罩）

1）分割网络，减少IP地址的浪费

2）计算网络号

##### 2、mmap内存映射过程

1）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域

2）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系

3）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝

##### 3、为什么友元函数要在类内声明

因为编译器必须能够**读取这个结构的声明以理解这个数据类型的大小**、行为等方面的所有规则。有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。

##### 4、结构体所占内存计算

```
struct st {
	short a;
	char b;
	float d;
	double c;
}; //占用16字节
struct st {
	short a;
	int b;
	double c;
	float d;
}; //占用24字节
```

##### 5、100M内存排序1G的数据

内存不够，采用外部排序的方法，采用归并排序。

1）将1G的数据拆分成10个100M，对其先进行内部排序；

2）在内存中开辟一个大小为10的最小堆，和一个缓冲区；

3）取排好序的10份数据的首位进入最小堆，则最小的数位于堆顶，移除堆顶元素并写入缓冲区，然后从移除元素的元素所属数组中的下一位进入最小堆，再移除堆顶元素进入缓冲区，直到缓冲区满，缓冲区回写磁盘，清空缓冲区，再次将数据置入最小堆；直到10份数据全部读完，最后将最小堆的元素按顺序写回磁盘即可；

##### 6、100万个数如何找最大的100个数

1、快排思想

2、建立最小堆

3、分块查找，先分成100份，找出最大的数，然后毕竟。再进行100份数据的最大数进行比较后，再取最大数所在组的第二大数，加入比较。

##### 7、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词

​        方案：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。

　　如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。

##### 8、吃羊问题

1）只有1老虎，1羊，那么这之羊会被吃；

2）2老虎，1羊，那么羊没有老虎敢吃；

3）3老虎，1羊，那么老虎吃羊后，就变成2老虎1羊的问题，没有敢吃，所以吃；

4）。。。

如果老虎是奇数，就吃羊，如果老虎是偶数，就不吃羊



## 乐鑫技术面二面7.2

##### 1、问项目、论文

##### 2、static用法

##### 3、程序编译后组成（没答好，栈、堆、未经初始化的变量，已经初始化的数据，代码段）

##### 4、如何知道程序编译后的各部分在操作系统中的位置

​		通过链接脚本选择位置。

##### 5、堆、栈区别

##### 6、操作系统的中断处理过程

1）中断请求

2）中断判优，CPU一次只能处理一个中断源的请求，当同时有多个中断源向CPU提出中断申请请求时，CPU必须找出中断优先级最高的中断源。

3）中断响应 （保护硬件现场；关中断；保护断点；获取中断服务程序的入口地址）

4）中断返回（返回到原程序的断点处，恢复硬件现场，继续执行原程序）

这里 ，中断返回操作是中断响应操作的逆过程

[中断处理的基本过程_Artorias的博客-CSDN博客_中断处理过程](https://blog.csdn.net/weixin_42240667/article/details/105071373)

##### 7、volatile关键字

##### 8、如何判断是大端存储还是小端存储？

1）利用大小端存储特性

① 定义一个 32 位的 int 型变量，0x11223344

② 将这个 int 型变量的低地址开始的 8 位存储的值取出来，取出来的方法就是利用强制类型转换

③ 如果这个值是 0x11 那么说明低地址存储了值的高位，所以为大端序

④ 如果这个值是 0x44 那么说明低地址存储了值的低位，所以为小端序

2）定义联合体，利用联合体共用内存的特点

```
union {
    int i;
    char c;
}un;
un.i=1;
if (un.c == 1)  printf("小端\n");
else   printf("大端\n");
```

##### 9、联合体（共同体）和结构体区别

“联合体”(union）与“结构体”(struct)有一些相似之处。但两者有本质上的不同。在结构体中,各成员有各自的内存空间, 一个结构变量的总长度是各成员长度之和。而在“联合”中,各成员共享一段内存空间, 一个联合变量的长度等于各成员中最长的长度。应该说明的是, 这里所谓的共享不是指把多个成员同时装入一个联合变量内, 而是指该联合变量可被赋予任一成员值,但每次只能赋一种值, 赋入新值则冲去旧值。

## 大华电话一面面经

纯聊项目

## 蔚来汽车一面 0710

1、项目  项目难点

2、手撕代码 两个栈实现一个队列

3、C++析构函数作用

4、C++三大特性

5、const用法（常量和函数？）

6、TCP三次握手、四次挥手；为什么挥手需要三次？

7、进程和线程，什么是进程？什么是线程？使用场景

8、http和https端口号（80、443）

## 蔚来汽车二面 0710

1、项目  项目难点（快递分拣）

2、手撕代码 链表找环

3、C++多态

4、重载和重写的区别

5、二叉树、队列、栈以及使用场景

6、进程间通信方式

7、二叉树，问了二叉搜索树和平衡二叉树

## 蔚来汽车三面 0710

##### 1、项目  项目难点（快递分拣）

##### 2、手撕代码 两个栈实现一个队列

##### 3、Linux指令，如何查看运行中的进程，显示磁盘内存占用空间，如何判断一个linux的版本号

##### 4、数据库连接池项目，询问如何优化（面试官提升熔断、需要支持主流数据库）

##### 5、讲一下fork

##### 6、进程线程通信方式

##### 7、多进程和多线程使用场景

##### 8、https如何加密

##### 9、TCP如何保证可靠性传输

##### 10、free命令：查看总内存、使用、空闲等情况

total：总计物理内存大小； used：已使用多大；  free：可拥有多少；  shared：多个进程共享的内存总额； buffers/cached：磁盘缓存的大小

##### 11、vmstat命令：查看CPU使用率、内存使用、IO读写情况

procs（进程）：r--运行队列中进程数量，这个值也可以判断是否需要增强CPU（长期大于1） --b 等待IO的进程数量；

memory（内存）：swap--使用虚拟内存大小；  free--空闲物理内存大小；  buff：用作缓冲的内存大小；  cache：用作缓存的内存大小；

CPU（以百分比表示）： us--用户进程执行时间百分比（user time）；  sy--内核系统进程执行时间百分比（system time）； wa：IO等待时间百分比； id：空闲时间百分比；

##### 12、http在四层网络协议的哪一层



## 百度一面

##### 1、deque的底层实现

deque和vector的最大差异是，deque允许以常数时间内对起头端进行元素的插入与删除操作；

deque没有所谓容量的概念，是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来；

对deque进行排序操作，为了最高效率，可将deque先完整复制到一个vector，将vector排序后，再复制回deque；

##### 2、红黑树底层实现

##### 3、哈希表底层实现，以及出现哈希冲突后，查询时间复杂度

哈希表的构造方法是：假设要存储的数据元素个数为n，设置一个长度为m（m≥n）的连续存储单元，分别以每个数据元素的关键字 *Ki(0<= i <=n-1)* 为自变量，通过哈希函数 *hash(Ki)* 把 *Ki* 映射为内存单元的某个地址 *hash(ki)*，并将该数据元素存储在该内存单元中。

构造哈希函数有三个要点：

第一，运算过程要尽量简单高效，以提高哈希表的插入和检索效率；

第二，哈希函数应该具有较好的散列性，以降低哈希冲突的概率；

第三，哈希函数应具有较大的压缩性，以节省内存。

1）直接定址法

2）除留余数法

3）数字分析法

出现哈希冲突后，查询时间最差复杂度是O(n);

##### 4、B+树、B树的区别

##### 5、单向链表和双向链表

##### 6、手写快排（没写出来，擦），为什么sort用快排

##### 7、项目问的少

##### 8、为什么MySQL数据库用B+树?

因为mysql是关系型数据库，数据遍历比较多。而B+ 树只需要去遍历叶子节点就可以实现整棵树的遍历。在数据库中基于范围的查询是非常频繁的，因此 MySQL 的 Innodb 引擎就使用了 B+ 树作为其索引的数据结构。

##### 9、vector插入元素

##### 10、栈和队列的区别，如何实现栈和队列（数组和链表）



## 大华二面

##### 1、介绍项目，项目难点

##### 2、C++虚函数作用，析构函数可以声明为虚函数吗，为什么，什么时候用到

##### 3、STL中vector和list区别

##### 4、STL迭代器作用，为什么需要它？（泛型编程，不暴露实现细节）

##### 5、程序的实现流程



## zeku技术一面

##### 1、介绍项目，与视觉slam区别

##### 2、做题：层序遍历二叉树

##### 3、做题：一个8字节的数的位为1的个数，如何用时间复杂度为1（用哈希表，空间换时间）



## 字节技术一面

##### 1、TCP和UDP区别

##### 2、虚拟地址和线性地址，以及具体实现过程

##### 3、为什么MySQL用B+树作索引

##### 4、代码题，二叉树右视图

##### 5、http状态码

5XX类表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码

500：服务器错误，无法完成请求；

501：尚未实施，服务器不具备完成请求的功能或不支持请求操作；

502：通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端发送了错误；

503：表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”；

504：网关超时；

505：不支持版本，表示服务器不支持请求中使用的HTTP协议版本；

##### 6、思维题，如何根据随机数函数打乱一个数组

##### 7、redis快照相关问题

##### [图解 Redis | 不就是 AOF 持久化嘛 - 小林coding - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaolincoding/p/14816503.html)

##### 8、什么是事务

## zeku技术二面

##### 1、聊项目

##### 2、聊规划



## 牛客面经--数据库

##### 1、mysql中索引优缺点

1）优点：

通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

2）缺点：

创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

##### 2、mysql和redis区别总结

1）类型上，mysql是关系型数据库，redis是缓存数据库；

2）作用上，mysql用于持久化的存储数据到硬盘，功能强大，但是速度慢；redis用于存储使用较为频繁的数据到缓存中，读取速度快；

3）存放位置上，mysql数据存放在磁盘；redis存放在内存；

##### 3、如何解决缓存不一致性问题

1）先删除缓存，再更新数据库。解决方案是使用延迟双删。

2）先更新数据库，再删除缓存。解决方案是消息队列或者其他binlog同步，引入消息队列会带来更多的问题，并不推荐直接使用。

3）针对缓存一致性要求不是很高的场景，那么只通过设置超时时间就可以了。

### 牛客面经--计算机网络

##### 1、http状态码

1xx：指示信息--表示请求已接收，继续处理。

2xx：成功--表示请求已被成功接收、理解、接受。

3xx：重定向--要完成请求必须进行更进一步的操作。

4xx：客户端错误--请求有语法错误或请求无法实现。

5xx：服务器端错误--服务器未能实现合法的请求。

##### 常见状态代码、状态描述的详细说明如下。

200 OK：客户端请求成功。

206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围

300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。

301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。

302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，

304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。

403 Forbidden：服务器收到请求，但是拒绝提供服务。

404 Not Found：请求资源不存在，举个例子：输入了错误的URL。



### 牛客面经--操作系统

##### 1、同步IO和异步IO区别

I/O是分为两个过程的：1）数据准备的过程；2）数据从内核空间拷贝到用户进程缓冲区；

异步IO和同步IO的区别在于请求数据是否需要等待

##### 2、LRU和LFU区别

LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面。

LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页。

比如,第二种方法的时期T为10分钟,如果每分钟进行一次调页,主存块为3,若所需页面走向为2 1 2 1 2 3 4

注意,当调页面4时会发生缺页中断，若按LRU算法,应换页面1(1页面最久未被使用) 但按LFU算法应换页面3(十分钟内,页面3只使用了一次)

可见LRU关键是看页面最后一次被使用到发生调度的时间长短,而LFU关键是看一定时间段内页面被使用的频率。

##### 3、缓冲与缓存的区别

缓存：常用数据存储到可以快速获取的区域,以备重复利用,一般叫做cache.  缓存能提高效率；

缓冲：在数据流转过程中,不同层次速度不一致时,利用缓冲区来缓解上下层之间速率问题,一般叫做buffer，缓冲能提高速度；

## 牛客面经--C++

##### 1、mutable关键字

mutable是可变的，易变的。在C++中，mutable也是为了突破const的限制而设置的，被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。

##### 2、栈溢出

对每个程序来说，栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误，程序就崩溃了。

##### 3、如何哈希扩容

如果一个hash表中桶的个数为 size , 存储的元素个数为used .则我们称 used / size 为负载因子loadFactor . 一般的情况下，当loadFactor<=1时，hash表查找的期望复杂度为O(1). 因此。每次往hash表中加入元素时。我们必须保证是在loadFactor <1的情况下，才可以加入。

**容量扩张（Expand）& 分摊转移**

当我们加入一个新元素时。一旦loadFactor大于等于1了，我们不能单纯的往hash表里边加入元素。

于是有了例如以下思路 ：Hash表中每次发现loadFactor==1时，就开辟一个原来桶数组的两倍空间（称为新桶数组），然后把原来的桶数组中元素所有转移过来到新的桶数组中。注意这里转移是须要元素一个个又一次哈希到新桶中的。原因后面会讲到。

这样的方法的缺点是，容量扩张是一次完毕的，期间要花非常长时间一次转移hash表中的全部元素。这样在hash表中loadFactor==1时。往里边插入一个元素将会等候非常长的时间。
redis中的dict.c中的设计思路是用两个hash表来进行进行扩容和转移的工作：当从第一个hash表的loadFactor=1时，假设要往字典里插入一个元素。首先为第二个hash表开辟2倍第一个hash表的容量。同一时候将第一个hash表的一个非空桶中元素所有转移到第二个hash表中。然后把待插入元素存储到第二个hash表里。继续往字典里插入第二个元素，又会将第一个hash表的一个非空桶中元素所有转移到第二个hash表中，然后把元素存储到第二个hash表里……直到第一个hash表为空。

这样的策略就把第一个hash表全部元素的转移分摊为多次转移，并且每次转移的期望时间复杂度为O(1)。

##### 3、如何让new失败不抛出异常

使用set_new_handler处理new失败；

##### 4、undefined reference产生在哪一步？

链接阶段

##### 5、volatile关键字

##### 作用：

防止编译器作优化，Volatile意思是“易变的”，应该解释为“直接存取原始内存地址”比较合适。“易变”是因为外在因素引起的，像多线程，中断等。

##### 用途：

1）并行设备的硬件寄存器（如：状态寄存器）；

2）中断服务程序中修改的供其他程序检测的变量（当变量在触发某中断程序中修改，而编译器判断主函数里面没有修改该变量，因此可能只执行一次从内存到某寄存器的读操作，而后每次只会从该寄存器中读取变量副本，使得中断程序的操作被短路。）

3）多任务环境下各任务间共享的标志（在本次线程内, 当读取一个变量时，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值；当内存变量或寄存器变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致 。）

##### 使用场景：

1）一个参数既可以是const还可以是volatile，如只读的状态寄存器；

2）一个指针可以是volatile，如一个中服务子程序修改一个指向buffer的指针；

#### 6、如何只在栈/堆上创建对象

1）只在堆上创建对象

①将析构函数声明为私有，但需要一个公有成员函数来进行释放内存的操作。缺点是无法解决继承问题。因为多态中，析构函数不能设为private，所以将析构函数设为protected；

②使用类似单例模式，将构造函数声明为protected，提供一个公有的static函数来完成构造；

2）只在栈上创建对象

new分为两步，只要让new不能调用operate new函数即可，在类内重载一个operate new函数，将其声明为私有；

##### 7、什么情况下必须使用拷贝构造函数

（1）用类的一个对象去初始化另一个对象时
（2）当函数的形参是类的对象时（也就是值传递时），如果是引用传递则不会调用
（3）当函数的返回值是类的对象或引用时

##### 8、为什么STL中默认排序用快排而不是用堆排？

1）在堆排序下，数据读取的开销大，堆排在建堆后，数据会跳着访问。

2）堆排会破坏数据本身的有序性

##### 9、operator new、new operator、placement new区别

1）new operator:分配足够的内存；调用构造函数

2）operator new：申请内存，底层用的malloc实现

3）placement new：不进行分配空间，而是在指定的空间上面进行调用构造函数。当然，在析构的时候，也只能显示的调用析构函数。（因为并不是真正的释放空间）

