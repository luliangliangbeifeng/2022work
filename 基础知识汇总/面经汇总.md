# 张铭招银网络一面

##### 1、大端模式和小端模式区别

区别：大端模式中字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中；而与大端存储模式相反，在小端存储模式中，低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节。

##### 2、堆与栈的区别

##### 3、static readonly和const的区别

##### 4、结构体和共同体的区别

1）变量长度不同

结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元。

共用体变量所占的内存长度等于最长的成员的长度。

2）占用空间不同

结构体是同时存在的，并一次占用一段连续的内存空间；

而共用体则是多个共用成员占用同一个开始的内存地址，同时他们只能存在一个，所以空间大小就是最大那个所需的空间，如果单从一个共用体来讲，我们是不知道里面存的是什么内容，需要根据程序上下文才能确定。

##### 5、线程调度中sleep和wait区别

（1）属于不同的两个类，sleep()方法是线程类（Thread）的静态方法，wait()方法是Object类里的方法。

（2）sleep()方法不会释放锁，wait()方法释放对象锁。

（3）sleep()方法可以在任何地方使用，wait()方法则只能在同步方法或同步块中使用。

（4）sleep()必须捕获异常，wait()方法、notify()方法和notiftAll()方法不需要捕获异常。

（5）sleep()使线程进入阻塞状态（线程睡眠），wait()方法使线程进入等待队列（线程挂起），也就是阻塞类别不同。

##### 6、完全二叉树和满二叉树的区别

满二叉树——除了叶结点外每一个结点都有左右子女且叶结点都处在最底层的二叉树,。（这个似乎很好想像出来）完全二叉树——只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树；（这个，就说从满二叉树里，最下一层的叶子，如果是从右往左拿掉叶子，不论多少，都是完全的，如果不是从右往左拿，而是在中间拿掉了一个，就是不完全的）

##### 7、什么是AVL树？

##### 8、const和define的区别

1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用。

2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 

3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。

4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。

**const优点**

1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。

3）const可节省空间，避免不必要的内存分配，提高效率；define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大，const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝；

##### 9、虚函数和纯虚函数

##### 10、引用传递和指针传递

​    指针参数传递本质上是值传递，它所传递的是一个地址值。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。

　　引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

　　引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。　　

##### 11、快排和冒泡排序

##### 12、虚函数和纯虚函数

##### 13、vector和list区别

##### 14、const int \* 和 int \* const

int const *p 和const int *p意义一样，指向常量的指针

##### 15、tcp长连接和短连接

##### 16、拥塞控制有哪些？讲一下慢开始

##### 17、tcp的keep alive

##### 18、代码驼峰

 

# 盛姜聪华泰面经

**1、介绍项目—识别魔方，解算过程**

##### 2、测试相关理论知识，测试与开发的差别

##### 3、数据库

##### 4、list中泛型添加多种数据，找出所有数字

##### 5、购物网站、购物车，有3种商品，2个苹果，3个李子，5个桃子， 5个苹果，6个李子，3个桃子，购物时连续点击；逻辑流程；

##### 6、未来3-5年职业规划

##### 7、为什么选择华泰

##### 8、什么是多态

##### 9、C++纯虚类特点、纯虚类主要用于哪些场合

##### 10、malloc和new的区别（new和free一起使用的后果）

##### 11、const char * 和char * const

##### 12、平衡二叉树和普通二叉树区别

##### 13、堆排序、快排的主要思路

##### 14、计算机课程，大端法和小端法

##### 15、浮点数保存，浮点数比较大小

##### 16、单例模式使用场合、工厂模式

##### 17、放弃本身经历选择金融科技，如何看待金融科技

##### 18、测试岗位在华泰证券公司的作用

##### 19、如何优化测试环节，完善测试用例等等；

##### 20、测试行业，如何证实代码是否正确，可以打印log，并加保护，测试方法；

##### 21、个人情况，家庭和对象，工作地点；

 

# 华泰一面

##### 1、指针和引用的区别（初始化的不同）

##### 2、虚函数，析构函数

##### 3、为什么用智能指针

##### 4、虚函数和纯虚函数

##### 5、如何在硬盘上找出所有相同的文件

##### 6、最大的优点、缺点，最有成就感的一件事

##### 7、项目（难点、意义、困难）

##### 8、最近关注哪些技术

 

# 嵌入式面经

##### 1、为什么嵌入式不用C++？

这是一种偏见，其实C++已经开始进入嵌入式

C++优势：1）C++是不断更新的语言

2）C++有着更加丰富的特性，三大特性

3）C++引进新的设计模式，面向对象；

为什么现在不用呢？++是面向对象的，成员函数的工作原理和普通函数不太一样，他的成员变量寻址全是偏移地址+基址。也就是基地址加偏址，通过改变基地址，让函数操作不同对象，但偏地址都相同（这样相同的代码实现操作不同的对象成员变量），电脑的CPU是有支持基址加偏址的，在BX里存基地址，在SI里存偏址，一条指令就找到变量了。而嵌入式芯片寻址要么立即数寻址，要么寄存器寻址，通常没有偏址+基址的方式，如果要实现只能软件去偏址+基址，运行更慢。

 

# Cadence面经

##### 1、vector、list区别

##### 2、链表倒数第N个结点

##### 3、虚函数

##### 4、找坏的药，12345编号

##### 5、析构函数什么时候被定义为虚函数

##### 6、项目实现

 

##### 1、函数指针和指针函数

函数指针是指向函数的指针int (*fun)(int x,int y);

指针函数是返回值为指针的函数int* fun(int x,int y);

 

##### 2、内联函数和宏定义区别

内联函数有安全检查，宏定义无安全检查

##### 3、虚函数表存放位置

编译后，存放在只读数据段

##### 4、虚继承、多重继承

虚继承是为了解决菱形继承的问题，虚继承只保存一份间接基类的成员；

##### 5、mmap

内存映射，mmap() 系统调⽤函数会直接把内核缓冲区⾥的数据「映射」到⽤户空间，这样，操作系统 内核与⽤户空间就不需要再进⾏任何的数据拷⻉操作。



# vivo技术面6.23

1、介绍项目，项目遇到的BUG，怎么解决的，出现的问题是什么

2、如何比较一个字符串是否是另一个字符串的子串

3、比较两个字符串大小、如果限定长度呢

4、C++多态有哪些？

5、反问，需要学习的知识、部门主要做什么的



# 乐鑫技术面一面6.22

1、问项目、论文

2、是否有硬件基础

3、反问，工作节奏，部门工作

# VIVO HR面6.25

1、自我介绍（共享屏幕，被说PPT制作质量低，亮点少）

2、工作地点、薪资期望

3、大公司与小公司的区别差异

4、逆商需要提高

5、智力题，八个苹果，找出一个质量重的那个，两次机会

6、反问，个人发展建议

7、公司录取你的原因和不录取你的原因

## 华为海思提前了解

1、struct对齐

2、C++新特性

3、项目详细介绍，RRT优化、VPG夹爪抓取

4、堆内存和栈内存

5、git介绍，提交代码遇到冲突、提交远端步骤

6、处理问题单的流程

##### 7、右值引用使用场景

移动拷贝构造函数

##### 1、子网掩码的作用（又称为网络掩码、地址掩码、子网络遮罩）

1）分割网络，减少IP地址的浪费

2）计算网络号

##### 2、mmap内存映射过程

1）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域

2）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系

3）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝

##### 3、为什么友元函数要在类内声明

因为编译器必须能够**读取这个结构的声明以理解这个数据类型的大小**、行为等方面的所有规则。有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。

##### 4、结构体所占内存计算

```
struct st {
	short a;
	char b;
	float d;
	double c;
}; //占用16字节
struct st {
	short a;
	int b;
	double c;
	float d;
}; //占用24字节
```

##### 5、100M内存排序1G的数据

内存不够，采用外部排序的方法，采用归并排序。

1）将1G的数据拆分成10个100M，对其先进行内部排序；

2）在内存中开辟一个大小为10的最小堆，和一个缓冲区；

3）取排好序的10份数据的首位进入最小堆，则最小的数位于堆顶，移除堆顶元素并写入缓冲区，然后从移除元素的元素所属数组中的下一位进入最小堆，再移除堆顶元素进入缓冲区，直到缓冲区满，缓冲区回写磁盘，清空缓冲区，再次将数据置入最小堆；直到10份数据全部读完，最后将最小堆的元素按顺序写回磁盘即可；

##### 6、100万个数如何找最大的100个数

1、快排思想

2、建立最小堆

3、分块查找，先分成100份，找出最大的数，然后毕竟。再进行100份数据的最大数进行比较后，再取最大数所在组的第二大数，加入比较。

##### 7、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词

​        方案：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。

　　如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。

##### 8、吃羊问题

1）只有1老虎，1羊，那么这之羊会被吃；

2）2老虎，1羊，那么羊没有老虎敢吃；

3）3老虎，1羊，那么老虎吃羊后，就变成2老虎1羊的问题，没有敢吃，所以吃；

4）。。。

如果老虎是奇数，就吃羊，如果老虎是偶数，就不吃羊



# 乐鑫技术面二面7.2

##### 1、问项目、论文

##### 2、static用法

##### 3、程序编译后组成（没答好，栈、堆、未经初始化的变量，已经初始化的数据，代码段）

##### 4、如何知道程序编译后的各部分在操作系统中的位置

​		通过链接脚本选择位置。

##### 5、堆、栈区别

##### 6、操作系统的中断处理过程

1）中断请求

2）中断判优，CPU一次只能处理一个中断源的请求，当同时有多个中断源向CPU提出中断申请请求时，CPU必须找出中断优先级最高的中断源。

3）中断响应 （保护硬件现场；关中断；保护断点；获取中断服务程序的入口地址）

4）中断返回（返回到原程序的断点处，恢复硬件现场，继续执行原程序）

这里 ，中断返回操作是中断响应操作的逆过程

[中断处理的基本过程_Artorias的博客-CSDN博客_中断处理过程](https://blog.csdn.net/weixin_42240667/article/details/105071373)

##### 7、volatile关键字

##### 8、如何判断是大端存储还是小端存储？

1）利用大小端存储特性

① 定义一个 32 位的 int 型变量，0x11223344

② 将这个 int 型变量的低地址开始的 8 位存储的值取出来，取出来的方法就是利用强制类型转换

③ 如果这个值是 0x11 那么说明低地址存储了值的高位，所以为大端序

④ 如果这个值是 0x44 那么说明低地址存储了值的低位，所以为小端序

2）定义联合体，利用联合体共用内存的特点

```
union {
    int i;
    char c;
}un;
un.i=1;
if (un.c == 1)  printf("小端\n");
else   printf("大端\n");
```

##### 9、联合体（共同体）和结构体区别

“联合体”(union）与“结构体”(struct)有一些相似之处。但两者有本质上的不同。在结构体中,各成员有各自的内存空间, 一个结构变量的总长度是各成员长度之和。而在“联合”中,各成员共享一段内存空间, 一个联合变量的长度等于各成员中最长的长度。应该说明的是, 这里所谓的共享不是指把多个成员同时装入一个联合变量内, 而是指该联合变量可被赋予任一成员值,但每次只能赋一种值, 赋入新值则冲去旧值。

